--------------------------------
--- MATERIALS (MODELS)
--------------------------------

ModelMaterials = {}
ModelMaterials.__index = ModelMaterials

-- materialID = String, all the modifications
local model = {
	list = {}
}

-- Get the old "newMaterial" from a unique model material name generated by this tool
function ModelMaterials:GetNew(materialID)
	local parts = string.Explode("-=+", materialID)
	local result

	if parts then
		result = parts[2]
	end

	return result
end

-- Get the original material full path
function ModelMaterials:GetOriginal(tr)
	if IsValid(tr.Entity) then
		return tr.Entity:GetMaterials()[1]
	end

	return nil
end

-- Get the current material full path
function ModelMaterials:GetCurrent(tr)
	if IsValid(tr.Entity) then
		local data = tr.Entity.modifiedMaterial
		local material = ""

		-- Get a material generated for the model
		if data then
			newMaterial = ModelMaterials:RevertID(data.newMaterial)
		-- Or the real thing
		else
			newMaterial = tr.Entity:GetMaterials()[1]
		end

		return newMaterial
	end

	return nil
end

-- Get the pure "newMaterial" from our ID
function ModelMaterials:RevertID(materialID)
	local parts = string.Explode("-=+", materialID)
	local result

	if parts then
		result = parts[2]
	end

	return result
end

-- Generate the material unique ID
function ModelMaterials:SetID(data)
	local materialID = ""

	-- SortedPairs so the order will be always the same
	for k,v in SortedPairs(data) do
		-- Remove the ent to avoid creating the same material later
		if v ~= data.ent then
			-- Separate the ID Generator (newMaterial) inside a "-=+" box
			if isstring(v) then
				if v == data.newMaterial then
					v = "-=+"..v.."-=+"
				end
			-- Round if it's a number
			elseif isnumber(v) then
				v = math.Round(v)
			end

			-- Generating...
			materialID = materialID..tostring(v)
		end
	end

	-- Remove problematic chars
	materialID = materialID:gsub(" ", "")
	materialID = materialID:gsub("%.", "")

	return materialID
end

-- Create a new model material (if it doesn't exist yet) and return its unique new name
function ModelMaterials:Create(data)
	local materialID = ModelMaterials:SetID(data)

	if CLIENT then
		-- Create the material if it's necessary
		if not model.list[materialID] then
			-- Basic info
			local material = {
				["$basetexture"] = data.newMaterial,
				["$vertexalpha"] = 0,
				["$vertexcolor"] = 1,
			}

			-- Create matrix
			local matrix = Matrix()

			matrix:SetAngles(Angle(0, data.rotation, 0)) -- Rotation
			matrix:Scale(Vector(1/data.scalex, 1/data.scaley, 1)) -- Scale
			matrix:Translate(Vector(data.offsetx, data.offsety, 0)) -- Offset

			-- Create material
			local newMaterial

			model.list[materialID] = CreateMaterial(materialID, "VertexLitGeneric", material)
			model.list[materialID]:SetTexture("$basetexture", Material(data.newMaterial):GetTexture("$basetexture"))
			newMaterial = model.list[materialID]

			-- Apply detail
			if data.detail ~= "None" then
				if Materials:GetDetailList()[data.detail] then
					newMaterial:SetTexture("$detail", Materials:GetDetailList()[data.detail]:GetTexture("$basetexture"))
					newMaterial:SetString("$detailblendfactor", "1")
				else
					newMaterial:SetString("$detailblendfactor", "0")
				end
			else
				newMaterial:SetString("$detailblendfactor", "0")
			end

			-- Try to apply Bumpmap ()
			local bumpmappath = data.newMaterial .. "_normal" -- checks for a file placed with the model (named like mymaterial_normal.vtf)
			local bumpmap = Material(data.newMaterial):GetTexture("$bumpmap") -- checks for a copied material active bumpmap

			if file.Exists("materials/"..bumpmappath..".vtf", "GAME") then
				if not model.list[bumpmappath] then
					model.list[bumpmappath] = CreateMaterial(bumpmappath, "VertexLitGeneric", {["$basetexture"] = bumpmappath})
				end
				newMaterial:SetTexture("$bumpmap", model.list[bumpmappath]:GetTexture("$basetexture"))
			elseif bumpmap then
				newMaterial:SetTexture("$bumpmap", bumpmap)
			end

			-- Apply matrix
			newMaterial:SetMatrix("$basetexturetransform", matrix)
			newMaterial:SetMatrix("$detailtexturetransform", matrix)
			newMaterial:SetMatrix("$bumptransform", matrix)
		end
	end

	return materialID
end

-- Set model material:::
if SERVER then
	util.AddNetworkString("ModelMaterials:Set")
end
function ModelMaterials:Set(ply, data)
	-- Check the entity
	if not IsValid(data.ent) then
		print("[MAP RETEXTURIZER] ModelMaterials:Set() received a invalid entity. Skipping it...")
	
		return false
	end

	if SERVER then
		-- Send the modification to...
		net.Start("ModelMaterials:Set")
			net.WriteTable(data)
		-- every player
		if not Ply:GetFirstSpawn(ply) or ply == Ply:GetFakeHostPly() then
			net.Broadcast()
		-- a single player
		else
			net.Send(ply)
		end
	end

	if CLIENT or SERVER and not Ply:GetFirstSpawn(ply) or SERVER and ply == Ply:GetFakeHostPly() then
		if SERVER then
			-- Set the duplicator
			duplicator.StoreEntityModifier(data.ent, "MapRetexturizer_Models", data)
		end

		-- Recreate the new material
		data.newMaterial = ModelMaterials:Create(data)

		-- Indicate that the model got modified by this tool
		data.ent.modifiedMaterial = data

		-- Set the alpha
		if SERVER then
			data.ent:SetRenderMode(RENDERMODE_TRANSALPHA)
			data.ent:SetColor(Color(255, 255, 255, 255 * data.alpha))
		-- Apply the material
		else
			data.ent:SetMaterial("!"..data.newMaterial)
		end	
	end

	return true
end
if CLIENT then
	net.Receive("ModelMaterials:Set", function(_,ply)
		ModelMaterials:Set(ply, net.ReadTable())
	end)
end

-- Remove a modified model material
if SERVER then
	util.AddNetworkString("ModelMaterials:Remove")
end
function ModelMaterials:Remove(ent)
	if not ent or not IsValid(ent) or not ent.modifiedMaterial then
		return false;
	end

	ent.modifiedMaterial = nil

	if SERVER then
		duplicator.ClearEntityModifier(ent, "MapRetexturizer_Models")

		net.Start("ModelMaterials:Remove")
			net.WriteEntity(ent)
		net.Broadcast()
	elseif CLIENT then
		ent:SetMaterial("")
		ent:SetRenderMode(RENDERMODE_NORMAL)
		ent:SetColor(Color(255,255,255,255))
	end

	return true
end
if CLIENT then
	net.Receive("ModelMaterials:Remove", function()
		ModelMaterials:Remove(net.ReadEntity())
	end)
end

-- Remove all modified model materials
function ModelMaterials:RemoveAll(ply)
	if CLIENT then return; end

	-- Admin only
	if not Utils:PlyIsAdmin(ply) then
		return false
	end

	-- Stop the duplicator
	Duplicator:ForceStop()

	-- Cleanup
	for k,v in pairs(ents.GetAll()) do
		if IsValid(v) then
			ModelMaterials:Remove(v)
		end
	end
end
if SERVER then
	util.AddNetworkString("ModelMaterials:RemoveAll")

	net.Receive("ModelMaterials:RemoveAll", function(_,ply)
		ModelMaterials:RemoveAll(ply)
	end)
end
